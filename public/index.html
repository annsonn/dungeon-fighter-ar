<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Dungeon Fighter AR</title>
    <meta name="description" content="Hello, World! â€¢ A-Frame three.ar.js">
    <script src="https://aframe.io/releases/0.6.1/aframe.min.js"></script>
    <script src="https://rawgit.com/google-ar/three.ar.js/master/dist/three.ar.js"></script>
    <script src="https://rawgit.com/chenzlabs/aframe-ar/master/dist/aframe-ar.js"></script>
    <script src="https://cdn.rawgit.com/donmccurdy/aframe-extras/master/dist/aframe-extras.min.js"></script>
    <!-- Include XZ grid shader. -->
    <script src="grid-shader.js"></script>

    <!-- Include polygon component. -->
    <script src="polygon.js"></script>
        
    <!-- Prevent touch causing flicker on iOS. -->
    <style> * { -webkit-tap-highlight-color: rgba(0,0,0,0); } </style>
  </head>
  <body>    
    <!-- This is the thing we stick in the middle of planes we detect. -->
    <script>
      AFRAME.registerComponent('thing', {
        init: function () {
          if (window.johnDebug) {
            this.el.setAttribute('geometry', {primitive:'box', width:0.01, depth:0.01, height:1});
            this.el.setAttribute('position', {y:0.5});  
          }
        }
      });
      
      AFRAME.registerComponent('force-pushable', {
        schema: {
          force: { default: 10 }
        },
        init: function () {
          var forcePushEvent = new CustomEvent('force-push', {});
          
          this.pStart = new THREE.Vector3();
          this.sourceEl = this.el.sceneEl.querySelector('[camera]');
          this.el.addEventListener('force-push', this.forcePush.bind(this));
        },
        forcePush: function () {
          var force,
              el = this.el,
              pStart = this.pStart.copy(this.sourceEl.getAttribute('position'));

          // Compute direction of force, normalize, then scale.
          force = el.body.position.vsub(pStart);
          force.normalize();
          force.scale(this.data.force, force);

          el.body.applyImpulse(force, el.body.position);
        }
      });
    </script>    

    <!-- Include planes handling example code. -->
    <script src="planes.js"></script>
    
    <style>

    </style> 
    
    <a-scene ar physics="friction: 0.1; restitution: 0.5; gravity:-9.8; iterations:100; debug: true">
      <!-- When we have a raycaster hit, we use this ball to show where. -->
      <a-sphere id="ball" radius="0.01" position="0 0.005 -0.5" dynamic-body="shape: box; mass: 0.1" force-pushable></a-sphere>
      
      <a-camera>
        <!-- A hit from AR, rather than A-Frame objects, hits this entity. -->
        <a-entity id="ar-world"></a-entity>
        
        <!-- Declare a cursor, and what objects its raycaster hit (including AR). -->
        <!-- NOTE: ar-raycaster VRHit uses a "tolerance" fudge factor, so imprecise -->
        <a-entity cursor="fuse:false"
                  raycaster="objects:.plane;recursive:false" 
                  ar-raycaster="el:#ar-world"></a-entity>
        
        <!-- Separate the cursor appearance.-->
        <a-entity position="0 0 -0.1"
                  scale="0.001 0.001 0.001"
                  geometry="primitive: ring; radiusInner: 0.0; radiusOuter: 1" 
                  material="color: yellow; shader: flat; transparent:true"></a-entity>
      
        
        <!-- Heads-up text display. -->
        
<!--
        <a-text id="hud" 
                scale="0.01 0.01 0.01" position="0 -0.025 -0.1" 
                color="yellow" align="center" 
                value="Hi there"></a-text>
-->
      </a-camera>
    </a-scene>    
    
    
    <script>
      var cameraPosition = {x: 0, y: 100, z: 100} ;
      
      document.querySelector('a-camera').addEventListener('componentchanged', function (evt) {
        if (evt.detail.name === 'position') {
          cameraPosition = evt.detail.newData;
        }
      });
      
      var sc = document.querySelector('a-scene');
      
      function addARRaycasterListeners() {
        var raycaster = sc.querySelector('[ar-raycaster]');
        // Note, -intersection is what the raycaster gets; the hit object gets -intersected.
        raycaster.addEventListener('raycaster-intersection', function (evt) {
          // Use first hit (which should be nearest).
          var point = evt.detail.intersections[0].point;
          var distance = evt.detail.intersections[0].distance;
          var el = evt.detail.els[0];
          showHUD('raycaster-intersection ' + distance + '\n' + JSON.stringify(point) + '\n' + el.id /*el.outerHTML*/);
          if (el.getAttribute('class') === 'plane') { el.setAttribute('opacity', 1.0); }
          ball.setAttribute('position', point);
          ball.setAttribute('visible', true);
        });
        raycaster.addEventListener('raycaster-intersection-cleared', function (evt) {
          var el = evt.detail.el;
          showHUD('raycaster-intersection-cleared\n' + el.outerHTML);
          if (el.getAttribute('class') === 'plane') { el.setAttribute('opacity', 0.5); }
          ball.setAttribute('visible', false);
        });
      }
      
      function addEventListeners() {
        addARRaycasterListeners();
        addPlaneListeners();
      }      
      
      function onSceneLoaded() { 
        var tempScale = new THREE.Vector3();
        var tempMat4 = new THREE.Matrix4();
        
        window.addEventListener('click', clickListener);
        
        addEventListeners();
      }
      
      if (sc.hasLoaded) { onSceneLoaded(); }
      else { sc.addEventListener('loaded', onSceneLoaded); }
      
    </script>
  </body>
</html>